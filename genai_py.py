# -*- coding: utf-8 -*-
"""GENAI.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fcNU2OvPq1wGpxLNjt3Ra03_bbPX4Urx
"""

#!/usr/bin/env python3
"""
AutoML Agent (Standalone .py)
- Prompts user for CSV path or file upload (if run in notebook, fallback to input).
- Asks for target column.
- Performs EDA, preprocessing, model selection, evaluation, and saves outputs.
- Minimal interactive CLI.

Run: python automl_agent.py
"""
import os
import sys
import json
import joblib
import warnings
warnings.filterwarnings('ignore')

import pandas as pd
import numpy as np
from datetime import datetime
from pathlib import Path

from sklearn.model_selection import train_test_split, StratifiedKFold, KFold, cross_val_score
from sklearn.preprocessing import LabelEncoder, OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer

from sklearn.metrics import (
    accuracy_score, f1_score, roc_auc_score, classification_report,
    mean_squared_error, mean_absolute_error, r2_score,
)
from sklearn.linear_model import LogisticRegression, Ridge
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from xgboost import XGBClassifier, XGBRegressor

import matplotlib.pyplot as plt

# =====================================================================
# Helpers
# =====================================================================

def ask(msg):
    return input(msg).strip()

# Detect regression vs classification

def detect_problem_type(y: pd.Series):
    if y.dtype == 'object' or str(y.dtype).startswith('category'):
        return 'classification'
    uniq = y.nunique()
    if uniq <= max(100, int(0.2 * len(y))):
        return 'classification'
    return 'regression'

# =====================================================================
# Main
# =====================================================================

def main():
    print("\n=== AutoML Agent (.py) ===")

    # Ask for dataset
    csv_path = ask("Enter path to CSV dataset: ")
    if not os.path.exists(csv_path):
        print("File not found.")
        sys.exit(1)

    df = pd.read_csv(csv_path)
    print("Loaded dataset with shape:", df.shape)

    print("Columns:", list(df.columns))
    target = ask("Enter target column name: ")
    if target not in df.columns:
        print("Invalid target column.")
        sys.exit(1)

    # Clean
    df = df.drop_duplicates().reset_index(drop=True)

    X = df.drop(columns=[target])
    y = df[target]

    num_cols = [c for c in X.columns if X[c].dtype != 'object']
    cat_cols = [c for c in X.columns if X[c].dtype == 'object']

    problem = detect_problem_type(y)
    print(f"Detected problem type: {problem}")

    label_encoder = None
    if problem == 'classification' and y.dtype == 'object':
        label_encoder = LabelEncoder()
        y = label_encoder.fit_transform(y)

    # Train/test split
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42,
        stratify=y if problem == 'classification' else None,
    )

    # Preprocessing
    numeric_pipe = Pipeline([
        ("imputer", SimpleImputer(strategy='median')),
        ("scaler", StandardScaler()),
    ])
    cat_pipe = Pipeline([
        ("imputer", SimpleImputer(strategy='most_frequent')),
        ("onehot", OneHotEncoder(handle_unknown='ignore', sparse_output=False)),
    ])

    preprocessor = ColumnTransformer([
        ("num", numeric_pipe, num_cols),
        ("cat", cat_pipe, cat_cols),
    ])

    # Candidate models
    if problem == 'classification':
        models = {
            "logreg": LogisticRegression(max_iter=1000),
            "rf": RandomForestClassifier(n_estimators=300),
            "xgb": XGBClassifier(n_estimators=400, learning_rate=0.05, eval_metric='logloss'),
        }
        scoring = 'f1_macro'
        cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
    else:
        models = {
            "ridge": Ridge(alpha=1.0),
            "rf": RandomForestRegressor(n_estimators=300),
            "xgb": XGBRegressor(n_estimators=400, learning_rate=0.05),
        }
        scoring = 'neg_root_mean_squared_error'
        cv = KFold(n_splits=5, shuffle=True, random_state=42)

    # Try models
    results = []
    for name, model in models.items():
        pipe = Pipeline([
            ("prep", preprocessor),
            ("model", model)
        ])
        scores = cross_val_score(pipe, X_train, y_train, cv=cv, scoring=scoring)
        results.append((name, scores.mean()))
        print(f"Model {name}: {scores.mean():.4f}")

    # Pick best
    best_name, _ = sorted(results, key=lambda x: x[1], reverse=True)[0]
    best_model = models[best_name]
    print(f"Best model: {best_name}")

    best_pipe = Pipeline([
        ("prep", preprocessor),
        ("model", best_model)
    ])
    best_pipe.fit(X_train, y_train)
    y_pred = best_pipe.predict(X_test)

    metrics = {}
    if problem == 'classification':
        metrics['accuracy'] = float(accuracy_score(y_test, y_pred))
        metrics['f1_macro'] = float(f1_score(y_test, y_pred, average='macro'))
    else:
        metrics['mae'] = float(mean_absolute_error(y_test, y_pred))
        metrics['rmse'] = float(np.sqrt(mean_squared_error(y_test, y_pred)))
        metrics['r2'] = float(r2_score(y_test, y_pred))

    print("\nMetrics:", json.dumps(metrics, indent=2))

    # Save outputs
    outdir = Path("automl_output")
    outdir.mkdir(exist_ok=True)

    model_path = outdir / f"best_model_{best_name}.joblib"
    joblib.dump({
        "pipeline": best_pipe,
        "target": target,
        "problem": problem,
        "label_encoder": label_encoder,
        "metrics": metrics,
    }, model_path)

    preds = pd.DataFrame({"actual": y_test, "pred": y_pred})
    preds.to_csv(outdir / "predictions.csv", index=False)

    with open(outdir / "metrics.json", 'w') as f:
        json.dump(metrics, f, indent=2)

    print(f"\nSaved model and outputs to: {outdir}")
    print("Done.")


if __name__ == '__main__':
    main()

